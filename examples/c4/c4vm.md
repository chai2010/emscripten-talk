# c4(c in 4 functions) 虚拟机简介

## 寄存器

- `a`  累加器
- `bp` 基址寄存器, 用于函数参数和局部变量偏移地址
- `sp` 堆栈寄存器, 栈由高地址向低地址生长
- `pc` 程序计数器
- `cycle` 执行指令计数

## 内存模型

- 指针和外部宿主的指针通用, 对应同一个地址空间
- 有自己独立的栈空间, 默认为256KB, 外部宿主的 `malloc` 分配
- 有自己独立的虚拟机指令段空间, 默认为256KB, 外部宿主的 `malloc` 分配
- 全局变量的地址作为立即数编码在指令中, 对应指令段空间
- 函数参数和局部变量保证在栈中

## 函数调用规范

调用参数从左向右依次进栈, 返回值存入累加器 `a`, 参数和返回值全部作为 `int` 处理.

## 指令集

1. `LEA` 取局部变量地址, 以 `[pc+1]` 地址, 以 `bp` 为基址, 地址载入累加器 `a`
1. `IMM` `[pc+1]` 作为立即数或全局变量地址载入累加器 `a`
1. `JMP` 无条件跳转到 `[pc+1]`
1. `JSR` 进入子程序, 将 `pc+2` 入栈作为返回地址, 跳转到 `[pc+1]`
1. `BZ`  `a` 为0时跳转到 `[pc+1]`
1. `BNZ` `a` 不为0时跳转到 `[pc+1]`
1. `ENT` 进入子程序, 将 `bp` 压栈, 基址 `bp` 指向栈顶, 然后将栈顶生长 `[pc+1]` 字, 为参数留出空间
1. `ADJ` 栈地址对齐
1. `LEV` 离开子程序, 堆栈指针从基址寄存器恢复 `sp = bp`, 从栈弹出基址 `bp`/`pc` 寄存器
1. `LI` 以 `a` 为地址取 `int` 数
1. `LC` 以 `a` 为地址取 `char` 数
1. `SI` 以栈顶为地址存 `int` 数并弹栈 `[[sp++]]=a`
1. `SC` 以栈顶为地址存 `char` 并弹栈 `[[sp++]]=a`
1. `PSH` 将 `a` 压栈
1. `OR`  `a = [sp++] | a`
1. `XOR` `a = [sp++] ^ a`
1. `AND` `a = [sp++] & a`
1. `EQ`  `a = [sp++] == a`
1. `NE`  `a = [sp++] != a`
1. `LT`  `a = [sp++] < a`
1. `GT`  `a = [sp++] > a`
1. `LE`  `a = [sp++] <= a`
1. `GE`  `a = [sp++] >= a`
1. `SHL` `a = [sp++] << a`
1. `SHR` `a = [sp++] >> a`
1. `ADD` `a = [sp++] + a`
1. `SUB` `a = [sp++] - a`
1. `MUL` `a = [sp++] * a`
1. `DIV` `a = [sp++] / a`
1. `MOD` `a = [sp++] % a`
1. `OPEN` 调用 `open`, 2个或3个参数, 但只使用了2个参数
1. `READ` 调用 `read`, 3个参数
1. `CLOS` 调用 `close`, 1个参数
1. `PRTF` 调用 `printf`, 可变参数, 最多传6个参数
1. `MALC` 调用 `malloc`, 1个参数
1. `MSET` 调用 `memset`, 3个参数
1. `MCMP` 调用 `memcmp`, 3个参数
1. `EXIT` 退出, 返回 `[sp]`

## 扩展指令

1. `WRTE` 调用 `write`, 2个参数
1. `FREE` 调用 `free`, 1个参数
1. `MMOV` 调用 `memmove`, 3个参数

## 其它

- 改进了`main`函数, 支持重入, 修复内存泄漏问题
- 支持C语言风格的注释
